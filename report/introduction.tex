\section{Introduction}
Sorting is an essential problem in computer science, due to the historical background and the many places it is used as a subroutine. Sorting comes in many variations, methods can be in-place, stable, external, adaptive and so on. Similarly one can analyse many aspects of sorting algorithms, such as number of element comparisons, runtime and number of element swaps.

% The hybrid sorting is used, may need a citation!!
Typically a hybrid method is used for sorting, in which one switches between different methods dependent on for example the number of elements, in order to alleviate some of the known drawbacks of the methods. An examples of this would be introsort\cite{m97}. Usually these methods fall back to a quadratic method on smaller inputs. This hybrid methods is often used in recursive strategies. In these hybrids the fall back method is called more than once and therefore any practical improvement in the runtime could yield a significant speedup. With this as motivation we look into alternatives for fallback methods, focusing on comparison optimal algorithms.

% Need motivation for then parellizing the method

The next section looks into the well-known Quicksort and Mergesort. It is then investigated if some of these methods can be speed up by proper use of allocation, memory and by manipulating access patterns. Following this the methods are parellelized.

The third section covers a classical method for nearly comparison optimal sorting of small sets. It is then optimized with respect to branches and branch misspredictions, in order to optimize the runtime.

The fourth section investigates the known sorting networks for small sets. It covers nearly comparison optimal sorting networks for 2 to 16 elements. They are too considered for branch optimization, in order to speed up the networks.

% Missing the rest of the sections