\section{Empirical investigation}
The sorting networks have been collected in a method that selects a prober
sized network for the input. These methods has been tested on an environment
with the specification depicted in figur~\ref{fig:pc1}\\

\begin{figure}
    \centering
    \begin{tabular}{ll}
            \textit{OS:} & Linux 64-bit\\
            \textit{Version:} & 4.8.4-1-ARCH\\
            \textit{Processor:} & Intel i5 2.67 GHz\\
            \textit{RAM:} & 12 GB\\
            \textit{Compiler:} & GNU, G++, 6.2.1
    \end{tabular}
    \caption{Benchmark machine 1}
    \label{fig:pc1}
\end{figure}

The methods have been averaged over a set of runs on a variation of smaller set
sizes. The result is depicted in figur~\ref{smalltablefigure}. It is clear from
the results that the branch optimization of Ford \& Johnson does not make a
significant speedup, in fact it seems to slow it down. This can be due to a lot of reasons, but most likely stems
from the fact that the few branches in the implementation does not contribute
that much to the runtime and changing it to far bigger mathematical statements does contribute quite a lot to the runtime. This gives an indication that one of the parts taking up time is index calculations. It is further evident that the Ford \& Johnson algorithm may
be close to comparison optimal, but in practice the needed support for that is too slow to compete with other methods.

Compared to the standard library sorting method, it is clear that the
specialized sorting networks achieve a better runtime. It seems to cut almost a third of most of the times. The standard
library of the gnu gcc compiler uses a hybrid between introsort, itself being a
hybrid, and insertion sort\cite{gnustd}. This method is slightly slower than then the networks, which could be due to overhead. Lastly we can see from the table that the optimal comparison sort achieves the same runtime as the sorting networks. This indicates that the networks achieves there potential in this particular setting.

\begin{figure}
\begin{tabular}{rrrrrrrrr}
    $N$ & \ttt{std::sort}   & \ttt{nsort()} & \ttt{fsort()} & Ford Johnson  & FJ branch optimized\\\hline
    2   & 12                & 9             & N/A           & 110       & 122\\
    4   & 32                & 21            & 21            & 247       & 319\\
    6   & 57                & 38            & 37            & 501       & 673\\
    8   & 89                & 60            & 60            & 603       & 683\\
    10  & 119               & 85            & N/A           & 895       & 1291\\
    12  & 154               & 115           & N/A           & 1018      & 1511\\
    14  & 192               & 147           & N/A           & 1375      & 2122\\
    16  & 233               & 148           & N/A           & 1609      & 2398\\
\end{tabular}
    \caption{Comparison of small sets specialized sortes and \ttt{std::sort}.
    \ttt{nsort()} is the sorting networks without branch optimization (due to
    \ttt{g++} not outputing \ttt{cmov}s). \ttt{fsort()} is sorters with optimal
    number of comparisons for $N$ elements. Machine see Figure \ref{fig:pc1}}
\label{smalltablefigure}
\end{figure}
